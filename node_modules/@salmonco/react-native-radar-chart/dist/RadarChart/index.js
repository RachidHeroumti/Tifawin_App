import React, { useMemo } from 'react';
import { View } from 'react-native';
import Svg, { Circle, Line, Polygon, Text } from 'react-native-svg';
import { getGradientColors } from './getGradientColors';
export default (function (_a) {
    var data = _a.data, _b = _a.size, size = _b === void 0 ? 330 : _b, _c = _a.scale, scale = _c === void 0 ? 1 : _c, _d = _a.maxValue, maxValue = _d === void 0 ? Math.max.apply(Math, data.map(function (v) { return v.value; })) : _d, fillColor = _a.fillColor, fillOpacity = _a.fillOpacity, gradientColor = _a.gradientColor, _e = _a.stroke, stroke = _e === void 0 ? [] : _e, _f = _a.strokeWidth, strokeWidth = _f === void 0 ? [] : _f, _g = _a.strokeOpacity, strokeOpacity = _g === void 0 ? [] : _g, labelSize = _a.labelSize, labelColor = _a.labelColor, labelFontFamily = _a.labelFontFamily, _h = _a.labelDistance, labelDistance = _h === void 0 ? 1.15 : _h, dataFillColor = _a.dataFillColor, dataFillOpacity = _a.dataFillOpacity, dataStroke = _a.dataStroke, dataStrokeWidth = _a.dataStrokeWidth, dataStrokeOpacity = _a.dataStrokeOpacity, divisionStroke = _a.divisionStroke, divisionStrokeWidth = _a.divisionStrokeWidth, divisionStrokeOpacity = _a.divisionStrokeOpacity, isCircle = _a.isCircle;
    var axesCnt = data.length;
    var internalAreaCnt = gradientColor ? gradientColor.count : 4;
    var degreesBetweenAxes = 360 / axesCnt;
    var viewBoxSize = scale === 0 ? 0 : size / scale;
    var viewBoxCenter = viewBoxSize * 0.5;
    var radius = size * 0.35;
    var gradients = gradientColor
        ? getGradientColors(gradientColor.startColor, gradientColor.endColor, gradientColor.count)
        : [];
    var degToRadians = function (degrees) { return degrees * (Math.PI / 180); };
    var svgY = function (degrees) { return degrees + 180; };
    var calculateEdgePoint = useMemo(function () {
        return function (index, scale) {
            if (scale === void 0) { scale = 1; }
            var degree = index * degreesBetweenAxes - degreesBetweenAxes * 0.75 * axesCnt;
            var degreeInRadians = degToRadians(degree);
            var degreeInRadiansY = degToRadians(svgY(degree));
            return [
                viewBoxCenter + Math.cos(degreeInRadians) * radius * scale,
                viewBoxCenter + Math.sin(degreeInRadiansY) * radius * scale,
            ];
        };
    }, [viewBoxCenter, radius, degreesBetweenAxes, axesCnt]);
    return (<View style={{
            width: size,
            height: size,
        }}>
      <Svg width="100%" height="100%" viewBox={"0 0 ".concat(viewBoxSize, " ").concat(viewBoxSize)}>
        {Array.from({ length: internalAreaCnt }, function (_, i) { return internalAreaCnt - i - 1; }).map(function (v) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            if (isCircle) {
                return (<Circle key={"circle_outline_".concat(v)} cx={viewBoxCenter} cy={viewBoxCenter} r={(v + 1) * (radius / internalAreaCnt)} stroke={(_a = stroke[v]) !== null && _a !== void 0 ? _a : 'white'} strokeWidth={(_b = strokeWidth[v]) !== null && _b !== void 0 ? _b : 0.5} strokeOpacity={(_c = strokeOpacity[v]) !== null && _c !== void 0 ? _c : 1} fill={(_e = (_d = gradients[v]) !== null && _d !== void 0 ? _d : fillColor) !== null && _e !== void 0 ? _e : 'salmon'} fillOpacity={fillOpacity !== null && fillOpacity !== void 0 ? fillOpacity : 1}/>);
            }
            else {
                var points = Array.from({ length: axesCnt }, function (_, i) {
                    var edgePoint = calculateEdgePoint(i, (v + 1) / internalAreaCnt);
                    return "".concat(edgePoint[0], ",").concat(edgePoint[1]);
                }).join(' ');
                return (<Polygon key={"polygon_outline_".concat(v)} points={points} stroke={(_f = stroke[v]) !== null && _f !== void 0 ? _f : 'white'} strokeWidth={(_g = strokeWidth[v]) !== null && _g !== void 0 ? _g : 0.5} strokeOpacity={(_h = strokeOpacity[v]) !== null && _h !== void 0 ? _h : 1} fill={(_k = (_j = gradients[v]) !== null && _j !== void 0 ? _j : fillColor) !== null && _k !== void 0 ? _k : 'salmon'} fillOpacity={fillOpacity !== null && fillOpacity !== void 0 ? fillOpacity : 1}/>);
            }
        })}
        {Array.from({ length: axesCnt }, function (_, i) { return (<Line key={"crosshair_".concat(i)} x1={viewBoxCenter} y1={viewBoxCenter} x2={calculateEdgePoint(i)[0]} y2={calculateEdgePoint(i)[1]} stroke={divisionStroke !== null && divisionStroke !== void 0 ? divisionStroke : 'white'} strokeWidth={divisionStrokeWidth !== null && divisionStrokeWidth !== void 0 ? divisionStrokeWidth : 1} strokeOpacity={divisionStrokeOpacity !== null && divisionStrokeOpacity !== void 0 ? divisionStrokeOpacity : '0.5'}/>); })}
        <Polygon fill={dataFillColor !== null && dataFillColor !== void 0 ? dataFillColor : 'green'} fillOpacity={dataFillOpacity !== null && dataFillOpacity !== void 0 ? dataFillOpacity : 1} stroke={dataStroke !== null && dataStroke !== void 0 ? dataStroke : undefined} strokeWidth={dataStrokeWidth !== null && dataStrokeWidth !== void 0 ? dataStrokeWidth : 1} strokeOpacity={dataStrokeOpacity !== null && dataStrokeOpacity !== void 0 ? dataStrokeOpacity : 1} points={"".concat(data.map(function (r, i) {
            var edgePoint = calculateEdgePoint(i, r.value / maxValue);
            return "".concat(edgePoint[0], ",").concat(edgePoint[1]);
        }))}/>
        {data.map(function (r, i) {
            var edgePoint = calculateEdgePoint(i, labelDistance);
            var fontSize = labelSize !== null && labelSize !== void 0 ? labelSize : 16;
            var color = labelColor !== null && labelColor !== void 0 ? labelColor : 'black';
            var fontFamily = labelFontFamily !== null && labelFontFamily !== void 0 ? labelFontFamily : 'Inter';
            var symmetricY = edgePoint[1] + fontSize / 2;
            return (<Text key={"label_".concat(r.label)} x={edgePoint[0]} y={symmetricY} textAnchor="middle" fontSize={fontSize} fill={color} fontFamily={fontFamily}>
              {r.label}
            </Text>);
        })}
      </Svg>
    </View>);
});
//# sourceMappingURL=index.js.map